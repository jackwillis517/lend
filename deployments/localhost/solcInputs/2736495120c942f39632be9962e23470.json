{
  "language": "Solidity",
  "sources": {
    "contracts/Lend.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.7.0 <0.9.0; \r\n\r\ncontract Lend {\r\n    uint256 LendJTokenBalance = 1000000000000;\r\n    mapping (address => uint256) Worthiness;\r\n    mapping (address => uint256) Staked;\r\n    mapping (address => uint256) TimeStaked;\r\n    mapping (address => uint256) Borrowed;\r\n    mapping (address => uint256) Debt;\r\n    mapping (address => uint256) Collateral;\r\n    mapping (address => bool) Blacklist;  \r\n\r\n    //-------------------------------Utility functions-------------------------------//\r\n    receive() external payable {}\r\n\r\n    fallback() external payable {}\r\n\r\n    // Adds a new borrower to the system with an initial worthiness of 500\r\n    function addNewBorrower() public {\r\n        require(Worthiness[msg.sender] == 0, \"This user is already registered.\");\r\n        Worthiness[msg.sender] = 500;\r\n    }\r\n\r\n    // Checks if a minute has passed since a lender has provided liquidity\r\n    function isTime(address lender) public view returns (bool) {\r\n        if(block.timestamp >= TimeStaked[lender] + 60) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function isBlacklisted(address person) public view returns (bool) {\r\n        return Blacklist[person];\r\n    }\r\n\r\n    function fundContract() public payable {\r\n        payable(address(this)).transfer(msg.value);\r\n    }\r\n\r\n\r\n    //-------------------------------View functions-------------------------------//\r\n    // Allows a borrower to view their current worthiness\r\n    function viewWorthiness() public view returns (uint256) {\r\n        require(Worthiness[msg.sender] > 0, \"User not found.\");\r\n        return Worthiness[msg.sender];\r\n    }\r\n\r\n    // Allows a lender to view their current Jtoken balance\r\n    function viewJtokenBalance() public view returns (uint256) {\r\n        return Staked[msg.sender];\r\n    }\r\n\r\n    function viewLiquidityTime() public view returns (uint256) {\r\n        return TimeStaked[msg.sender];\r\n    }\r\n\r\n    function viewContractBalance() public view returns (uint256) {\r\n        return LendJTokenBalance; \r\n    }\r\n\r\n    function viewCollateral() public view returns (uint256) {\r\n        return Collateral[msg.sender];\r\n    } \r\n\r\n    function viewDebt() public view returns (uint256) {\r\n        return Debt[msg.sender];\r\n    }\r\n\r\n\r\n    //-------------------------------Lending workflow-------------------------------//\r\n    // Allows a lender to provide liquidity to Lend in return for redeemable interest tokens\r\n    // A lender can only lend once for now and each JToken is worth 2 ETH for now\r\n    function provideLiquidity() public payable {\r\n        require(LendJTokenBalance > 0, \"Lend is out of redeemable tokens at this time.\");\r\n        require(Staked[msg.sender] == 0, \"You have already provided liquidity and must wait to do it again.\");\r\n        Staked[msg.sender] += msg.value / 1e18;\r\n        LendJTokenBalance -= msg.value / 1e18;\r\n        TimeStaked[msg.sender] = block.timestamp;\r\n        payable(address(this)).transfer(msg.value); \r\n    }\r\n\r\n    // Allows a lender to claim their interest token's value after the loan expires\r\n    // Right now a loan expires after a minute, ideally I'd like to add a more robust\r\n    // liquidation scheme in the future based on time and value from a price oracle\r\n    function claimInterest() public payable {\r\n        require(isTime(msg.sender), \"You need to wait until the loan expires.\");\r\n        require(Staked[msg.sender] > 0, \"No liquidity was provided to collect interest on.\");\r\n        LendJTokenBalance += Staked[msg.sender];\r\n        payable(msg.sender).transfer((Staked[msg.sender] * 2) * 1e18); \r\n        Staked[msg.sender] = 0;\r\n    } \r\n\r\n\r\n    //-------------------------------Borrowing workflow-------------------------------//\r\n    // Allows a borrow to see how much collateral and debt would be incurred to borrow a specific amount\r\n    function checkBorrow (uint256 amount) public view returns (uint256, uint256) {\r\n        require(Blacklist[msg.sender] != true, \"This borrower cannot be trusted, loan denied.\");\r\n        require(Worthiness[msg.sender] > 0, \"This user hasn't registered yet, please register your wallet.\");\r\n        require(Debt[msg.sender] == 0, \"This person has already borrowed ether.\");\r\n        uint256 amountInEther = amount * 1e18;\r\n\r\n        // Debt & Collateral are recorded in Finney because of fractional values\r\n        // Debt = (1 + (worthiness/1000)) * amount borrowed\r\n        // Collateral = (worthiness/1000) * amount borrowed\r\n        uint256 projectedDebt = ((1000 + Worthiness[msg.sender]) * (amountInEther / 1e15)) / 1e3;\r\n        uint256 projectedCollateral = ((Worthiness[msg.sender]) * (amountInEther / 1e15)) / 1e3;\r\n\r\n        return (projectedDebt, projectedCollateral);\r\n    }\r\n    \r\n    // Allows a borrower to borrow ether from the protocol\r\n    function borrowLiquidity (uint256 amount) public payable returns (bool) {\r\n        require(Blacklist[msg.sender] != true, \"This borrower cannot be trusted, loan denied.\");\r\n        require(Worthiness[msg.sender] > 0, \"This user hasn't registered yet, please register your wallet.\");\r\n        require(Debt[msg.sender] == 0, \"This person has already borrowed ether.\");\r\n        uint256 amountInEther = amount * 1e18;\r\n        require((msg.value / 1e15) == ((Worthiness[msg.sender]) * (amountInEther / 1e15)) / 1e3, \"The amount of collateral isn't enough.\");\r\n        Borrowed[msg.sender] = block.timestamp;\r\n        \r\n\r\n        // Debt & Collateral are recorded in Finney because of fractional values\r\n        // Debt = (1 + (worthiness/1000)) * amount borrowed\r\n        // Collateral = (worthiness/1000) * amount borrowed\r\n        // Record the amount a borrower has to repay with interest in FINNEY\r\n        Debt[msg.sender] = ((1000 + Worthiness[msg.sender]) * (amountInEther / 1e15)) / 1e3;\r\n\r\n        // Record the amount a borrower must provide as collateral in order to borrow in FINNEY\r\n        Collateral[msg.sender] = ((Worthiness[msg.sender]) * (amountInEther / 1e15)) / 1e3;\r\n\r\n\r\n        // Transfer the required collateral from the borrower to the contract\r\n        payable(address(this)).transfer(msg.value);\r\n                               \r\n        // Transfer the desired borrow amount to the borrower\r\n        payable(msg.sender).transfer(amountInEther);\r\n\r\n\r\n        return true;\r\n    }\r\n    \r\n    // Allows a borrower to pay off their debt\r\n    function makePayment() public payable returns (bool) {\r\n        require(Debt[msg.sender] > 0, \"The loan is already paid off.\");\r\n\r\n        if(block.timestamp <= Borrowed[msg.sender] + 60){\r\n            // Update the users debt\r\n            Debt[msg.sender] -= (msg.value / 1e15);\r\n            payable(address(this)).transfer(msg.value);\r\n\r\n            // If the user settles all of their debt then return their collateral and halve their worthiness\r\n            if(Debt[msg.sender] == 0){\r\n                payable(msg.sender).transfer(Collateral[msg.sender] * 1e15);\r\n                Worthiness[msg.sender] = Worthiness[msg.sender] / 2;\r\n\r\n                // Ensure their Worthiness doesn't drop below 50\r\n                if(Worthiness[msg.sender] < 50){\r\n                    Worthiness[msg.sender] = 50;\r\n                }\r\n            }\r\n\r\n          // If the user attempts to make a payment after the loan expires double their worthiness\r\n          // If their worthiness exceeds 1000 mark them blacklisted\r\n          // Reset the users Collateral and Debt obligation\r\n        } else {\r\n            Collateral[msg.sender] = 0;\r\n            Debt[msg.sender] = 0;\r\n            Worthiness[msg.sender] = Worthiness[msg.sender] * 2;\r\n            if(Worthiness[msg.sender] >= 1000){\r\n                Blacklist[msg.sender] = true;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}